# Requirement-analysis2.0
REQUIREMENT ANALYSIS IN SOFTWARE ENGINEERING2.0
# Introduction
The Requirement Analysis Project focuses on crafting a comprehensive foundation for software development by documenting, analyzing, and structuring requirements. Through a series of well-defined tasks, learners will create a detailed blueprint of the requirement analysis phase for a booking management system. This project simulates a real-world development scenario, emphasizing clarity, precision, and structure in defining requirements to set the stage for successful project execution.
# What is requirement analysis??
Requirement analysis is a critical phase in the software development lifecycle (SDLC) where the needs and expectations of stakeholders are gathered, examined, and clearly defined to guide the design and implementation of a software system. This process involves engaging with users, clients, and other stakeholders to understand what the software must accomplish, how it should behave, and any constraints it must operate within. It includes activities such as requirement elicitation, documentation, validation, and prioritization. The importance of requirement analysis lies in its ability to establish a shared understanding between developers and stakeholders before any coding begins. By clearly defining functional and non-functional requirements early on, teams reduce the risk of building a system that does not meet user needs or business goals. It helps prevent scope creep, minimize costly rework, and improve overall project planning. In essence, requirement analysis forms the foundation for all subsequent phases of development — including design, testing, and deployment — and significantly contributes to the success and quality of the final software product.
# Why is requirement analysis important.
* Prevents miscomunication and misalignment: Requirement analysis ensures that developers, stakeholders, and end-users all share a clear, common understanding of what the system should do. Without this step, teams risk building a product that doesn’t match user needs or business goals, leading to dissatisfaction or project failure.
* Reduces costly rework: Identifying requirements early helps catch potential issues or gaps before development begins. Fixing mistakes during or after implementation is much more expensive than resolving them at the planning stage, so thorough analysis can save both time and money.
* Improves planing and estimation: Clear and detailed requirements allow project managers to create accurate timelines, allocate resources efficiently, and define project scope. This helps avoid scope creep and supports better decision-making throughout the development process.
# Key activities in requirement analysis.
* Requireent gathering: this has to do with interviews, surveys, observations etc.
* Requirement elictation: Brainsrorming, focus groups, prototyping.
* Requirement documentation: involves user cases, user stories, requirement specification document.
* Requirement analysis and modeling: modeling, feasibility, feedback.
* Requirement validation: Review and approval, acceptance criteria, traceabiity.
# Functional requirements
* Customer service(search + booking): The hotel booking service is designed to allow customers to search and book hotels through a dedicated portal. This portal provides personalized content such as nearby hotels, recommendations, and special offers using a content delivery network (CDN). When hotel data is updated, it is sent to a messaging queue system. A consumer service then processes this data and stores it in Elasticsearch, which is a NoSQL database known for its efficient search capabilities. When a customer uses the app to search for hotels or make a booking, their request first reaches an API, which is handled by a load balancer. The load balancer distributes the request to the appropriate backend service based on the type of request. The search service is responsible for retrieving hotel data from Elasticsearch, while the booking service manages hotel bookings and interacts with a third-party payment service. The booking service also uses Redis, a caching system, to store temporary data. This reduces the load on the main booking database and improves the overall response time of the API. Any updates made to the booking database are sent back into the messaging queue. From there, the consumer processes the data and stores it in Cassandra, a NoSQL database optimized for handling large volumes of historical data. Cassandra is used specifically for archiving purposes to keep the main database lean, which helps maintain fast query times as the data grows over time. This architecture ensures efficient data processing, quick response times, and scalability for both customer-facing and backend operations.
* View booking service: Here all current and old booking details are shown to the user. Both managers and customers use this service. The Customer/Manager app sends the request to the load balancer and it distributes the request to booking management servers. Then the service request for data through Redis and Cassandra. through Redis, it requests recent data as it is a caching server. Which could reduce the loading time on the app side.
# Non functional requirements
* Hotel management servive: This is the service that will be given to hotel managers/owners. In this managers can manage their hotel's related information. Here managers have a separate portal to access the data and update it. Whenever an API is triggered from the hotel manager app the initial request is been sent to the load balancer, then the load balancer distributes the requests to the desired server to process. The hotel service cluster has multiple servers that have the container for hotel service-related API. Now, this hotel service interacts with the Hotel DB cluster which follows the master-slave architecture to reduce the load in the database. Basically, in this approach, we create a replica of the master database which are called a slave database. Master DB is used for a write operation and slave DB is used for reading operation only. Whenever a write operation is performed on the master database it syncs the data to the slave database. Whenever any data is updated in the database API sends the data to the CDN(Content Distributed Network) and to a Messaging Queue System(like Kafka, RabbitMQ) for further processing. A CDN is a geographically distributed group of servers that work together to provide fast delivery of Internet content.
* Final design: As you can see in the above design there is a Kafka consumer for notification, notification consumers send the notification. That could be to the customer/manager, like whenever a customer books a hotel notification is sent to the manager or if a new offers come it’s notified to the customer. Apache Streaming service takes the data from messaging queue and stores it in Hadoop which could be used for BigData analysis for multiple purposes. Like business analysis, finding potential customers, audience categorisations etc.
# Use case diagram
Use case diagrams are a type of UML (Unified Modeling Language) diagram that visually represents how users, known as actors, interact with a system to achieve specific goals. Each interaction or task the user performs with the system is represented as a "use case." These diagrams show the relationships between the actors (such as users or external systems) and the use cases (functionalities or services the system provides), helping to define the system’s scope and behavior from a user's perspective.
# Benefits of use case diagram
* The main benefit of use case diagrams is that they offer a clear, high-level overview of system functionality in a format that is easy to understand for both technical and non-technical stakeholders.
* They help in identifying the key users of a system, the features those users need, and the boundaries of the system itself.
* Use case diagrams are useful during the requirements analysis phase of software development because they support communication, reduce ambiguity, and provide a foundation for creating more detailed design and test documentation.
# Acceptance criteria
play a crucial role in requirement analysis by clearly defining the conditions that a feature or functionality must meet in order to be considered complete and acceptable to stakeholders. These criteria act as a bridge between what stakeholders expect and what developers deliver, helping ensure that everyone has a shared understanding of what success looks like for a given requirement. In requirement analysis, acceptance criteria bring precision and clarity to user stories or functional requirements. They remove ambiguity by outlining the specific inputs, behaviors, and outcomes a feature should have. This helps developers know exactly what to build, testers know what to verify, and stakeholders know what to approve. Well-written acceptance criteria reduce misunderstandings, limit the chances of rework, and serve as the foundation for quality assurance and user acceptance testing. Overall, acceptance criteria are essential for turning broad business goals into actionable and testable items, making them a key part of delivering software that meets user needs and business objectives.
# An example of acceptance criteria for a checking feature in the booking management system
* Booking summary is displayed: When the user clicks “Checkout,” they should see a summary of their selected booking, including hotel name, dates, total price, and guest details.
* Payment options: The user must be able to choose from available payment methods (e.g., credit/debit card, mobile money, or third-party gateway).
* Secure payment integration: The system must connect securely to the external payment provider, and sensitive data must be handled in accordance with industry standards (e.g., no plain text card storage).
* Successful payment confirmation: After a successful payment, the user should see a confirmation message and receive an email with their booking reference number.
* Error handling on payment failure: If the payment fails (e.g., insufficient funds or network issue), an appropriate error message must be shown, and the user must have the option to retry.
* Booking status is updated: After successful payment, the booking status in the system should be updated to “Confirmed.”
* No duplicate charges: the system must prevent multiple charges if the user refreshes or resubmits the payment page.
# Use case diagram file link 
![https://drive.google.com/file/d/1Nahx1VP5w4Ag28nMGe2LUMVQPnADaUYp/view?usp=sharing]
